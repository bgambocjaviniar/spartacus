<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>storefrontapp documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css" media="(prefers-color-scheme: dark)">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">storefrontapp documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li
  >
  DeprecatedNode</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/schematics/src/shared/utils/file-utils.ts</code>
        </p>




        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#comment" 
>
                                            comment
                                        </a>
                                </li>
                                <li>
                                        <a href="#importPath" 
>
                                            importPath
                                        </a>
                                </li>
                                <li>
                                        <a href="#node" 
>
                                            node
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="comment"></a>
                                        <span class="name "><b>comment</b>
                                            <a href="#comment">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>comment:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="importPath"></a>
                                        <span class="name "><b>importPath</b>
                                            <a href="#importPath">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>importPath:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="node"></a>
                                        <span class="name "><b>node</b>
                                            <a href="#node">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>node:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { strings } from &#x27;@angular-devkit/core&#x27;;
import { SchematicsException, Tree } from &#x27;@angular-devkit/schematics&#x27;;
import type { Element, Node } from &#x27;@angular/compiler&#x27;;
import {
  findNode,
  findNodes,
  getSourceNodes,
  insertImport,
  isImported,
} from &#x27;@schematics/angular/utility/ast-utils&#x27;;
import {
  Change,
  InsertChange,
  NoopChange,
  RemoveChange,
  ReplaceChange,
} from &#x27;@schematics/angular/utility/change&#x27;;
import ts from &#x27;typescript&#x27;;
import {
  ANGULAR_CORE,
  INJECT_DECORATOR,
  TODO_SPARTACUS,
  UTF_8,
} from &#x27;../constants&#x27;;
import {
  getAngularJsonFile,
  getDefaultProjectNameFromWorkspace,
} from &#x27;./workspace-utils&#x27;;

export enum InsertDirection {
  LEFT,
  RIGHT,
}

export interface ClassType {
  className: string;
  importPath?: string;
  literalInference?: string;
  injectionToken?: {
    token: string;
    importPath?: string;
    isArray?: boolean;
  };
}

interface InjectServiceConfiguration {
  constructorNode: ts.Node | undefined;
  path: string;
  serviceName: string;
  modifier: &#x27;private&#x27; | &#x27;protected&#x27; | &#x27;public&#x27; | &#x27;no-modifier&#x27;;
  propertyName?: string;
  propertyType?: string;
  injectionToken?: string;
  isArray?: boolean;
}

export interface ComponentProperty {
  /** property name */
  name: string;
  /** comment describing the change to the property */
  comment: string;
}
export interface ComponentData {
  /** a component&#x27;s selector, e.g. cx-start-rating */
  selector: string;
  /** a component.ts&#x27; class name */
  componentClassName: string;
  /** only &#x60;@Input&#x60; and &#x60;@Output&#x60; properties should be listed here */
  removedInputOutputProperties?: ComponentProperty[];
  /** all other removed component properties should be listed here */
  removedProperties?: ComponentProperty[];
}

export interface ConstructorDeprecation {
  class: string;
  importPath: string;
  deprecatedParams: ClassType[];

  /** The list of constructor parameters that are _added_ for the given version. */
  addParams?: ClassType[];

  /** The list of constructor parameters that are _removed_ for the given version. */
  removeParams?: ClassType[];
}

export interface MethodPropertyDeprecation {
  class: string;
  importPath: string;
  deprecatedNode: string;
  newNode?: string;
  comment?: string;
}

export interface DeprecatedNode {
  node: string;
  importPath: string;
  comment?: string;
}

export interface ConfigDeprecation {
  propertyName: string;
  comment: string;
}

export interface RenamedSymbol {
  previousNode: string;
  previousImportPath: string;
  newNode?: string;
  newImportPath?: string;
}

export function getTsSourceFile(tree: Tree, path: string): ts.SourceFile {
  const buffer &#x3D; tree.read(path);
  if (!buffer) {
    throw new SchematicsException(&#x60;Could not read file (${path}).&#x60;);
  }
  const content &#x3D; buffer.toString(UTF_8);
  const source &#x3D; ts.createSourceFile(
    path,
    content,
    ts.ScriptTarget.Latest,
    true
  );

  return source;
}

export function getAllTsSourceFiles(
  tree: Tree,
  basePath: string
): ts.SourceFile[] {
  const results: string[] &#x3D; [];
  tree.getDir(basePath).visit((filePath) &#x3D;&gt; {
    if (filePath.endsWith(&#x27;.ts&#x27;)) {
      results.push(filePath);
    }
  });

  return results.map((f) &#x3D;&gt; getTsSourceFile(tree, f));
}

export function getIndexHtmlPath(tree: Tree): string {
  const projectName &#x3D; getDefaultProjectNameFromWorkspace(tree);
  const angularJson &#x3D; getAngularJsonFile(tree);
  const indexHtml: string &#x3D; (
    angularJson.projects[projectName]?.architect?.build?.options as any
  )?.index;
  if (!indexHtml) {
    throw new SchematicsException(&#x27;&quot;index.html&quot; file not found.&#x27;);
  }

  return indexHtml;
}

export function getPathResultsForFile(
  tree: Tree,
  file: string,
  directory?: string
): string[] {
  const results: string[] &#x3D; [];
  const dir &#x3D; directory || &#x27;/&#x27;;

  tree.getDir(dir).visit((filePath) &#x3D;&gt; {
    if (filePath.endsWith(file)) {
      results.push(filePath);
    }
  });

  return results;
}

export function getHtmlFiles(
  tree: Tree,
  fileName &#x3D; &#x27;.html&#x27;,
  directory?: string
): string[] {
  return getPathResultsForFile(tree, fileName || &#x27;.html&#x27;, directory);
}

export function insertComponentSelectorComment(
  content: string,
  componentSelector: string,
  componentProperty: ComponentProperty
): string | undefined {
  const selector &#x3D; buildSelector(componentSelector);
  const comment &#x3D; buildHtmlComment(componentProperty.comment);

  let index: number | undefined &#x3D; 0;
  let newContent &#x3D; content;
  while (true) {
    index &#x3D; getTextPosition(newContent, selector, index);
    if (index &#x3D;&#x3D; null) {
      break;
    }

    newContent &#x3D; newContent.slice(0, index) + comment + newContent.slice(index);
    index +&#x3D; comment.length + componentSelector.length;
  }

  return newContent;
}

function getTextPosition(
  content: string,
  text: string,
  startingPosition &#x3D; 0
): number | undefined {
  const index &#x3D; content.indexOf(text, startingPosition);
  return index !&#x3D;&#x3D; -1 ? index : undefined;
}

function buildSelector(selector: string): string {
  return &#x60;&lt;${selector}&#x60;;
}

function visitHtmlNodesRecursively(
  angularCompiler: typeof import(&#x27;@angular/compiler&#x27;),
  nodes: Node[],
  propertyName: string,
  resultingElements: Node[] &#x3D; [],
  parentElement?: Element
): void {
  const { Attribute, Element } &#x3D; angularCompiler;
  nodes.forEach((node) &#x3D;&gt; {
    if (node instanceof Attribute &amp;&amp; parentElement) {
      if (
        node.name.includes(propertyName) ||
        node.value.includes(propertyName)
      ) {
        resultingElements.push(parentElement);
      }
    }
    if (node instanceof Element) {
      visitHtmlNodesRecursively(
        angularCompiler,
        node.attrs,
        propertyName,
        resultingElements,
        node
      );
      visitHtmlNodesRecursively(
        angularCompiler,
        node.children,
        propertyName,
        resultingElements,
        node
      );
    }
  });
}

export function insertHtmlComment(
  content: string,
  componentProperty: ComponentProperty,
  angularCompiler: typeof import(&#x27;@angular/compiler&#x27;)
): string | undefined {
  const { HtmlParser } &#x3D; angularCompiler;
  const comment &#x3D; buildHtmlComment(componentProperty.comment);
  const result &#x3D; new HtmlParser().parse(content, &#x27;&#x27;);

  const resultingElements: Node[] &#x3D; [];
  visitHtmlNodesRecursively(
    angularCompiler,
    result.rootNodes,
    componentProperty.name,
    resultingElements
  );

  resultingElements
    .map((node: Node) &#x3D;&gt; node.sourceSpan.start.line)
    .forEach((line, i) &#x3D;&gt; {
      const split &#x3D; content.split(&#x27;\n&#x27;);
      split.splice(line + i, 0, comment);
      content &#x3D; split.join(&#x27;\n&#x27;);
    });

  return content;
}

function buildHtmlComment(commentText: string): string {
  return &#x60;&lt;!-- ${TODO_SPARTACUS} ${commentText} --&gt;&#x60;;
}

export function commitChanges(
  host: Tree,
  path: string,
  changes: Change[] | null,
  insertDirection: InsertDirection &#x3D; InsertDirection.RIGHT
): void {
  if (!changes || changes.length &#x3D;&#x3D;&#x3D; 0) {
    return;
  }

  const recorder &#x3D; host.beginUpdate(path);
  changes.forEach((change) &#x3D;&gt; {
    if (change instanceof InsertChange) {
      const pos &#x3D; change.pos;
      const toAdd &#x3D; change.toAdd;
      if (insertDirection &#x3D;&#x3D;&#x3D; InsertDirection.LEFT) {
        recorder.insertLeft(pos, toAdd);
      } else {
        recorder.insertRight(pos, toAdd);
      }
    } else if (change instanceof RemoveChange) {
      const pos &#x3D; change[&#x27;pos&#x27;];
      const length &#x3D; change[&#x27;toRemove&#x27;].length;
      recorder.remove(pos, length);
    } else if (change instanceof NoopChange) {
      // nothing to do here...
    } else {
      const pos &#x3D; (change as ReplaceChange)[&#x27;pos&#x27;];
      const oldText &#x3D; (change as ReplaceChange)[&#x27;oldText&#x27;];
      const newText &#x3D; (change as ReplaceChange)[&#x27;newText&#x27;];

      recorder.remove(pos, oldText.length);
      if (insertDirection &#x3D;&#x3D;&#x3D; InsertDirection.LEFT) {
        recorder.insertLeft(pos, newText);
      } else {
        recorder.insertRight(pos, newText);
      }
    }
  });
  host.commitUpdate(recorder);
}

export function findConstructor(nodes: ts.Node[]): ts.Node | undefined {
  return nodes.find((n) &#x3D;&gt; n.kind &#x3D;&#x3D;&#x3D; ts.SyntaxKind.Constructor);
}

export function defineProperty(
  nodes: ts.Node[],
  path: string,
  toAdd: string
): InsertChange {
  const constructorNode &#x3D; findConstructor(nodes);

  if (!constructorNode) {
    throw new SchematicsException(&#x60;No constructor found in ${path}.&#x60;);
  }

  return new InsertChange(path, constructorNode.pos + 1, toAdd);
}

/**
 *
 * Method performs the following checks on the provided &#x60;source&#x60; file:
 * - is the file inheriting the provided &#x60;constructorDeprecation.class&#x60;
 * - is the &#x60;constructorDeprecation.class&#x60; imported from the specified &#x60;constructorDeprecation.importPath&#x60;
 * - is the file importing all the provided &#x60;parameterClassTypes&#x60; from the expected import path
 * - does the provided file contain a constructor
 * - does the &#x60;super()&#x60; call exist in the constructor
 * - does the param number passed to &#x60;super()&#x60; match the expected number
 * - does the order and the type of the constructor parameters match the expected &#x60;parameterClassTypes&#x60;
 *
 * If only once condition is not satisfied, the method returns &#x60;false&#x60;. Otherwise, it returns &#x60;true&#x60;.
 *
 * @param source a ts source file
 * @param inheritedClass a class which customers might have extended
 * @param parameterClassTypes a list of parameter class types. Must be provided in the order in which they appear in the deprecated constructor.
 */
export function isCandidateForConstructorDeprecation(
  source: ts.SourceFile,
  constructorDeprecation: ConstructorDeprecation
): boolean {
  const nodes &#x3D; getSourceNodes(source);

  if (!isInheriting(nodes, constructorDeprecation.class)) {
    return false;
  }

  if (
    !isImported(
      source,
      constructorDeprecation.class,
      constructorDeprecation.importPath
    )
  ) {
    return false;
  }

  if (!checkImports(source, constructorDeprecation.deprecatedParams)) {
    return false;
  }

  const constructorNode &#x3D; findConstructor(nodes);
  if (!constructorNode) {
    return false;
  }

  if (
    !checkConstructorParameters(
      constructorNode,
      constructorDeprecation.deprecatedParams
    )
  ) {
    return false;
  }

  if (!checkSuper(constructorNode, constructorDeprecation.deprecatedParams)) {
    return false;
  }

  return true;
}

export function isInheriting(
  nodes: ts.Node[],
  inheritedClass: string
): boolean {
  const heritageClauseNodes &#x3D; nodes.filter(
    (node) &#x3D;&gt; node.kind &#x3D;&#x3D;&#x3D; ts.SyntaxKind.HeritageClause
  );
  const heritageNodes &#x3D; findMultiLevelNodesByTextAndKind(
    heritageClauseNodes,
    inheritedClass,
    ts.SyntaxKind.Identifier
  );
  return heritageNodes.length !&#x3D;&#x3D; 0;
}

function checkImports(
  source: ts.SourceFile,
  parameterClassTypes: ClassType[]
): boolean {
  for (const classImport of parameterClassTypes) {
    if (
      classImport.importPath &amp;&amp;
      !isImported(source, classImport.className, classImport.importPath)
    ) {
      return false;
    }
  }
  return true;
}

function checkConstructorParameters(
  constructorNode: ts.Node,
  parameterClassTypes: ClassType[]
): boolean {
  const constructorParameters &#x3D; findNodes(
    constructorNode,
    ts.SyntaxKind.Parameter
  );

  const foundClassTypes: ClassType[] &#x3D; [];
  for (const parameterClassType of parameterClassTypes) {
    for (const constructorParameter of constructorParameters) {
      const constructorParameterType &#x3D; findNodes(
        constructorParameter,
        ts.SyntaxKind.Identifier
      ).filter((node) &#x3D;&gt; node.getText() &#x3D;&#x3D;&#x3D; parameterClassType.className);

      if (constructorParameterType.length !&#x3D;&#x3D; 0) {
        foundClassTypes.push(parameterClassType);
        /*
        the break is needed to cope with multiple parameters of one type,
        e.g. constructor migrations for
       constructor(
          protected cartStore: Store&lt;StateWithMultiCart&gt;,
          protected store: Store&lt;StateWithConfigurator&gt;,
          protected configuratorUtilsService: ConfiguratorUtilsService
        ) {}    */
        break;
      }
    }
  }

  return foundClassTypes.length &#x3D;&#x3D;&#x3D; parameterClassTypes.length;
}

function isInjected(
  constructorNode: ts.Node,
  parameterClassType: ClassType
): boolean {
  const constructorParameters &#x3D; findNodes(
    constructorNode,
    ts.SyntaxKind.Parameter
  );

  for (const constructorParameter of constructorParameters) {
    const constructorParameterType &#x3D; findNodes(
      constructorParameter,
      ts.SyntaxKind.Identifier
    ).filter((node) &#x3D;&gt; node.getText() &#x3D;&#x3D;&#x3D; parameterClassType.className);

    if (constructorParameterType.length &gt; 0) {
      return true;
    }
  }

  return false;
}

function checkSuper(
  constructorNode: ts.Node,
  parameterClassTypes: ClassType[]
): boolean {
  const constructorBlock &#x3D; findNodes(constructorNode, ts.SyntaxKind.Block)[0];
  const callExpressions &#x3D; findNodes(
    constructorBlock,
    ts.SyntaxKind.CallExpression
  );
  if (callExpressions.length &#x3D;&#x3D;&#x3D; 0) {
    return false;
  }
  // super has to be the first expression in constructor
  const firstCallExpression &#x3D; callExpressions[0];
  const superKeyword &#x3D; findNodes(
    firstCallExpression,
    ts.SyntaxKind.SuperKeyword
  );
  if (superKeyword &amp;&amp; superKeyword.length &#x3D;&#x3D;&#x3D; 0) {
    return false;
  }

  const params &#x3D; findNodes(firstCallExpression, ts.SyntaxKind.Identifier);
  if (params.length !&#x3D;&#x3D; parameterClassTypes.length) {
    return false;
  }

  return true;
}

export function addConstructorParam(
  source: ts.SourceFile,
  sourcePath: string,
  constructorNode: ts.Node | undefined,
  paramToAdd: ClassType
): Change[] {
  if (!constructorNode) {
    throw new SchematicsException(&#x60;No constructor found in ${sourcePath}.&#x60;);
  }
  const changes: Change[] &#x3D; [];
  if (!isInjected(constructorNode, paramToAdd)) {
    changes.push(
      injectService({
        constructorNode,
        path: sourcePath,
        serviceName: paramToAdd.className,
        modifier: &#x27;no-modifier&#x27;,
        propertyType: paramToAdd.literalInference,
        injectionToken: paramToAdd.injectionToken?.token,
        isArray: paramToAdd.injectionToken?.isArray,
      })
    );
  }

  if (
    paramToAdd.importPath &amp;&amp;
    !isImported(source, paramToAdd.className, paramToAdd.importPath)
  ) {
    changes.push(
      insertImport(
        source,
        sourcePath,
        paramToAdd.className,
        paramToAdd.importPath
      )
    );
  }
  if (paramToAdd.injectionToken?.token) {
    if (!isImported(source, INJECT_DECORATOR, ANGULAR_CORE)) {
      changes.push(
        insertImport(source, sourcePath, INJECT_DECORATOR, ANGULAR_CORE)
      );
    }

    /**
     * This is for the case when an injection token is the same as the import&#x27;s type.
     * In this case we don&#x27;t want to add two imports.
     * Ex: &#x60;@Inject(LaunchRenderStrategy) launchRenderStrategy: LaunchRenderStrategy[]&#x60;
     */
    if (
      paramToAdd.injectionToken.importPath &amp;&amp;
      paramToAdd.injectionToken.token !&#x3D;&#x3D; paramToAdd.className &amp;&amp;
      !isImported(
        source,
        paramToAdd.injectionToken.token,
        paramToAdd.injectionToken.importPath
      )
    ) {
      changes.push(
        insertImport(
          source,
          sourcePath,
          paramToAdd.injectionToken.token,
          paramToAdd.injectionToken.importPath
        )
      );
    }
  }

  const paramName &#x3D; getParamName(source, constructorNode, paramToAdd);
  changes.push(
    updateConstructorSuperNode(
      sourcePath,
      constructorNode,
      paramName || paramToAdd.className
    )
  );

  return changes;
}

export function removeConstructorParam(
  source: ts.SourceFile,
  sourcePath: string,
  constructorNode: ts.Node | undefined,
  paramToRemove: ClassType
): Change[] {
  if (!constructorNode) {
    throw new SchematicsException(&#x60;No constructor found in ${sourcePath}.&#x60;);
  }

  const changes: Change[] &#x3D; [];

  if (shouldRemoveImportAndParam(source, paramToRemove)) {
    const importRemovalChange &#x3D; removeImport(source, paramToRemove);
    const injectImportRemovalChange &#x3D; removeInjectImports(
      source,
      constructorNode,
      paramToRemove
    );
    const constructorParamRemovalChanges &#x3D; removeConstructorParamInternal(
      sourcePath,
      constructorNode,
      paramToRemove
    );

    changes.push(
      importRemovalChange,
      ...constructorParamRemovalChanges,
      ...injectImportRemovalChange
    );
  }
  const paramName &#x3D; getParamName(source, constructorNode, paramToRemove);
  if (!paramName) {
    return [new NoopChange()];
  }

  const superRemoval &#x3D; removeParamFromSuper(
    sourcePath,
    constructorNode,
    paramName
  );
  changes.push(...superRemoval);

  return changes;
}

export function shouldRemoveDecorator(
  constructorNode: ts.Node,
  decoratorIdentifier: string
): boolean {
  const decoratorParameters &#x3D; findNodes(
    constructorNode,
    ts.SyntaxKind.Decorator
  ).filter((x) &#x3D;&gt; x.getText().includes(decoratorIdentifier));

  // if there are 0, or exactly 1 usage of the &#x60;decoratorIdentifier&#x60; in the whole class, we can safely remove it.
  return decoratorParameters.length &lt; 2;
}

function getParamName(
  source: ts.SourceFile,
  constructorNode: ts.Node,
  classType: ClassType
): string | undefined {
  const nodes &#x3D; getSourceNodes(source);

  const constructorParameters &#x3D; findNodes(
    constructorNode,
    ts.SyntaxKind.Parameter
  );
  const classDeclarationNode &#x3D; nodes.find(
    (node) &#x3D;&gt; node.kind &#x3D;&#x3D;&#x3D; ts.SyntaxKind.ClassDeclaration
  );
  if (!classDeclarationNode) {
    return undefined;
  }

  for (const constructorParameter of constructorParameters) {
    if (getClassName(constructorParameter) &#x3D;&#x3D;&#x3D; classType.className) {
      const paramVariableNode &#x3D; constructorParameter
        .getChildren()
        .find((node) &#x3D;&gt; node.kind &#x3D;&#x3D;&#x3D; ts.SyntaxKind.Identifier);
      const paramName &#x3D; paramVariableNode
        ? paramVariableNode.getText()
        : undefined;
      return paramName;
    }
  }

  return undefined;
}

function getClassName(constructorParameter: ts.Node): string | undefined {
  const identifierNode &#x3D; constructorParameter
    .getChildren()
    .find((node) &#x3D;&gt; node.kind &#x3D;&#x3D;&#x3D; ts.SyntaxKind.TypeReference)
    ?.getChildren()
    .find((node) &#x3D;&gt; node.kind &#x3D;&#x3D;&#x3D; ts.SyntaxKind.Identifier);

  return identifierNode ? identifierNode.getText() : undefined;
}

function shouldRemoveImportAndParam(
  source: ts.SourceFile,
  importToRemove: ClassType
): boolean {
  const nodes &#x3D; getSourceNodes(source);
  const constructorNode &#x3D; findConstructor(nodes);
  if (!constructorNode) {
    return true;
  }

  const classDeclarationNode &#x3D; nodes.find(
    (node) &#x3D;&gt; node.kind &#x3D;&#x3D;&#x3D; ts.SyntaxKind.ClassDeclaration
  );
  if (!classDeclarationNode) {
    return true;
  }

  const constructorParameters &#x3D; getConstructorParameterList(constructorNode);
  for (const constructorParameter of constructorParameters) {
    if (constructorParameter.getText().includes(importToRemove.className)) {
      const paramVariableNode &#x3D; constructorParameter
        .getChildren()
        .find((node) &#x3D;&gt; node.kind &#x3D;&#x3D;&#x3D; ts.SyntaxKind.Identifier);
      const paramName &#x3D; paramVariableNode ? paramVariableNode.getText() : &#x27;&#x27;;

      const paramUsages &#x3D; findNodes(
        classDeclarationNode,
        ts.SyntaxKind.Identifier
      ).filter((node) &#x3D;&gt; node.getText() &#x3D;&#x3D;&#x3D; paramName);
      // if there are more than two usages (injection and passing to super), then the param is used elsewhere in the class
      if (paramUsages.length &gt; 2) {
        return false;
      }

      return true;
    }
  }

  return true;
}

export function removeInjectImports(
  source: ts.SourceFile,
  constructorNode: ts.Node,
  paramToRemove: ClassType
): Change[] {
  if (!paramToRemove.injectionToken) {
    return [new NoopChange()];
  }

  const importRemovalChange: Change[] &#x3D; [];

  if (shouldRemoveDecorator(constructorNode, INJECT_DECORATOR)) {
    importRemovalChange.push(
      removeImport(source, {
        className: INJECT_DECORATOR,
        importPath: ANGULAR_CORE,
      })
    );
  }

  /**
   * This is for the case when an injection token is the same as the import&#x27;s type.
   * In this case we don&#x27;t want to have two import removal changes.
   * Ex: &#x60;@Inject(LaunchRenderStrategy) launchRenderStrategy: LaunchRenderStrategy[]&#x60;
   */
  if (
    paramToRemove.injectionToken.importPath &amp;&amp;
    paramToRemove.injectionToken.token !&#x3D;&#x3D; paramToRemove.className
  ) {
    importRemovalChange.push(
      removeImport(source, {
        className: paramToRemove.injectionToken.token,
        importPath: paramToRemove.injectionToken.importPath,
      })
    );
  }

  return importRemovalChange;
}

export function removeImport(
  source: ts.SourceFile,
  importToRemove: ClassType
): Change {
  const importDeclarationNode &#x3D; getImportDeclarationNode(
    source,
    importToRemove
  );
  if (!importDeclarationNode) {
    return new NoopChange();
  }

  let position: number;
  let toRemove &#x3D; importToRemove.className;
  const importSpecifierNodes &#x3D; findNodes(
    importDeclarationNode,
    ts.SyntaxKind.ImportSpecifier
  );
  if (importSpecifierNodes.length &#x3D;&#x3D;&#x3D; 1) {
    // delete the whole import line
    position &#x3D; importDeclarationNode.getStart();
    toRemove &#x3D; importDeclarationNode.getText();
  } else {
    // delete only the specified import, and leave the rest
    const importSpecifier &#x3D; importSpecifierNodes
      .map((node, i) &#x3D;&gt; {
        const importNode &#x3D; findNode(
          node,
          ts.SyntaxKind.Identifier,
          importToRemove.className
        );
        return {
          importNode,
          i,
        };
      })
      .filter((result) &#x3D;&gt; result.importNode)[0];

    if (!importSpecifier.importNode) {
      return new NoopChange();
    }

    // in case the import that needs to be removed is in the middle, we need to remove the &#x27;,&#x27; that follows the found import
    if (importSpecifier.i !&#x3D;&#x3D; importSpecifierNodes.length - 1) {
      toRemove +&#x3D; &#x27;,&#x27;;
    }

    position &#x3D; importSpecifier.importNode.getStart();
  }
  return new RemoveChange(source.fileName, position, toRemove);
}

function getImportDeclarationNode(
  source: ts.SourceFile,
  importToCheck: ClassType
): ts.Node | undefined {
  if (!importToCheck.importPath) {
    return undefined;
  }

  // collect al the import declarations
  const importDeclarationNodes &#x3D; getImportDeclarations(
    source,
    importToCheck.importPath
  );

  if (importDeclarationNodes.length &#x3D;&#x3D;&#x3D; 0) {
    return undefined;
  }

  // find the one that contains the specified &#x60;importToCheck.className&#x60;
  let importDeclarationNode &#x3D; importDeclarationNodes[0];
  for (const currentImportDeclaration of importDeclarationNodes) {
    const importIdentifiers &#x3D; findNodes(
      currentImportDeclaration,
      ts.SyntaxKind.Identifier
    );
    const found &#x3D; importIdentifiers.find(
      (node) &#x3D;&gt; node.getText() &#x3D;&#x3D;&#x3D; importToCheck.className
    );
    if (found) {
      importDeclarationNode &#x3D; currentImportDeclaration;
      break;
    }
  }

  return importDeclarationNode;
}

function getConstructorParameterList(constructorNode: ts.Node): ts.Node[] {
  const syntaxList &#x3D; constructorNode
    .getChildren()
    .filter((node) &#x3D;&gt; node.kind &#x3D;&#x3D;&#x3D; ts.SyntaxKind.SyntaxList)[0];
  return findNodes(syntaxList, ts.SyntaxKind.Parameter);
}

function removeConstructorParamInternal(
  sourcePath: string,
  constructorNode: ts.Node,
  importToRemove: ClassType
): Change[] {
  const constructorParameters &#x3D; getConstructorParameterList(constructorNode);

  for (let i &#x3D; 0; i &lt; constructorParameters.length; i++) {
    const constructorParameter &#x3D; constructorParameters[i];
    if (constructorParameter.getText().includes(importToRemove.className)) {
      const changes: RemoveChange[] &#x3D; [];
      // if it&#x27;s not the first parameter that should be removed, we should remove the comma after the previous parameter
      if (i !&#x3D;&#x3D; 0) {
        const previousParameter &#x3D; constructorParameters[i - 1];
        changes.push(new RemoveChange(sourcePath, previousParameter.end, &#x27;,&#x27;));
        // if removing the first param, cleanup the comma after it
      } else if (i &#x3D;&#x3D;&#x3D; 0 &amp;&amp; constructorParameters.length &gt; 1) {
        const commas &#x3D; findNodes(constructorNode, ts.SyntaxKind.CommaToken);
        // get the comma that matches the constructor parameter&#x27;s position
        const comma &#x3D; commas[i];
        changes.push(new RemoveChange(sourcePath, comma.getStart(), &#x27;,&#x27;));
      }

      changes.push(
        new RemoveChange(
          sourcePath,
          constructorParameter.getStart(),
          constructorParameter.getText()
        )
      );
      return changes;
    }
  }
  return [];
}

function removeParamFromSuper(
  sourcePath: string,
  constructorNode: ts.Node,
  paramName: string
): Change[] {
  const constructorBlock &#x3D; findNodes(constructorNode, ts.SyntaxKind.Block)[0];
  const callExpressions &#x3D; findNodes(
    constructorBlock,
    ts.SyntaxKind.CallExpression
  );
  if (callExpressions.length &#x3D;&#x3D;&#x3D; 0) {
    throw new SchematicsException(&#x27;No super() call found.&#x27;);
  }

  const changes: Change[] &#x3D; [];

  // &#x60;super()&#x60; has to be the first expression in constructor
  const firstCallExpression &#x3D; callExpressions[0];
  const params &#x3D; findNodes(firstCallExpression, ts.SyntaxKind.Identifier);
  const commas &#x3D; findNodes(firstCallExpression, ts.SyntaxKind.CommaToken);
  for (let i &#x3D; 0; i &lt; params.length; i++) {
    const param &#x3D; params[i];

    if (param.getText() &#x3D;&#x3D;&#x3D; paramName) {
      if (i !&#x3D;&#x3D; 0) {
        const previousCommaPosition &#x3D; commas[i - 1].getStart();
        changes.push(new RemoveChange(sourcePath, previousCommaPosition, &#x27;,&#x27;));
        // if removing the first param, cleanup the comma after it
      } else if (i &#x3D;&#x3D;&#x3D; 0 &amp;&amp; params.length &gt; 0) {
        // get the comma that matches the constructor parameter&#x27;s position
        const comma &#x3D; commas[i];
        changes.push(new RemoveChange(sourcePath, comma.getStart(), &#x27;,&#x27;));
      }

      changes.push(new RemoveChange(sourcePath, param.getStart(), paramName));

      break;
    }
  }

  return changes;
}

function updateConstructorSuperNode(
  sourcePath: string,
  constructorNode: ts.Node,
  propertyName: string
): InsertChange {
  const callBlock &#x3D; findNodes(constructorNode, ts.SyntaxKind.Block);
  propertyName &#x3D; strings.camelize(propertyName);

  if (callBlock.length &#x3D;&#x3D;&#x3D; 0) {
    throw new SchematicsException(&#x27;No constructor body found.&#x27;);
  }

  const callExpression &#x3D; findNodes(callBlock[0], ts.SyntaxKind.CallExpression);

  // super has to be the first expression in constructor
  const firstCallExpression &#x3D; callExpression[0];
  const superKeyword &#x3D; findNodes(
    firstCallExpression,
    ts.SyntaxKind.SuperKeyword
  );

  if (superKeyword &amp;&amp; superKeyword.length &#x3D;&#x3D;&#x3D; 0) {
    throw new SchematicsException(&#x27;No super() call found.&#x27;);
  }

  let toInsert &#x3D; &#x27;&#x27;;
  let position: number;
  const params &#x3D; findNodes(firstCallExpression, ts.SyntaxKind.Identifier);
  // just an empty super() call, without any params passed to it
  if (params.length &#x3D;&#x3D;&#x3D; 0) {
    position &#x3D; superKeyword[0].end + 1;
  } else {
    const lastParam &#x3D; params[params.length - 1];
    toInsert +&#x3D; &#x27;, &#x27;;
    position &#x3D; lastParam.end;
  }

  toInsert +&#x3D; propertyName;
  return new InsertChange(sourcePath, position, toInsert);
}

export function injectService(
  config: InjectServiceConfiguration
): InsertChange {
  if (!config.constructorNode) {
    throw new SchematicsException(&#x60;No constructor found in ${config.path}.&#x60;);
  }

  const constructorParameters &#x3D; getConstructorParameterList(
    config.constructorNode
  );

  let toInsert &#x3D; &#x27;&#x27;;
  let position &#x3D; config.constructorNode.getStart() + &#x27;constructor(&#x27;.length;
  if (constructorParameters.length &gt; 0) {
    toInsert +&#x3D; &#x27;, &#x27;;
    const lastParam &#x3D; constructorParameters[constructorParameters.length - 1];
    position &#x3D; lastParam.end;
  }

  config.propertyName &#x3D; config.propertyName
    ? strings.camelize(config.propertyName)
    : strings.camelize(config.serviceName);

  config.propertyType &#x3D;
    config.propertyType ?? strings.classify(config.serviceName);

  if (config.injectionToken) {
    toInsert +&#x3D; &#x60;@Inject(${config.injectionToken}) &#x60;;
  }
  if (config.modifier !&#x3D;&#x3D; &#x27;no-modifier&#x27;) {
    toInsert +&#x3D; &#x60;${config.modifier} &#x60;;
  }
  toInsert +&#x3D; &#x60;${config.propertyName}: ${config.propertyType}&#x60;;

  if (config.isArray) {
    toInsert +&#x3D; &#x27;[]&#x27;;
  }

  return new InsertChange(config.path, position, toInsert);
}

export function buildSpartacusComment(comment: string): string {
  return &#x60;// ${TODO_SPARTACUS} ${comment}\n&#x60;;
}

export function insertCommentAboveConfigProperty(
  sourcePath: string,
  source: ts.SourceFile,
  identifierName: string,
  comment: string
): Change[] {
  const identifierNodes &#x3D; new Set&lt;ts.Node&gt;();
  getSourceNodes(source)
    .filter((node) &#x3D;&gt; node.kind &#x3D;&#x3D;&#x3D; ts.SyntaxKind.ObjectLiteralExpression)
    .forEach((objectLiteralNode) &#x3D;&gt;
      findNodes(objectLiteralNode, ts.SyntaxKind.Identifier)
        .filter((node) &#x3D;&gt; node.getText() &#x3D;&#x3D;&#x3D; identifierName)
        .forEach((idNode) &#x3D;&gt; identifierNodes.add(idNode))
    );

  const changes: Change[] &#x3D; [];
  identifierNodes.forEach((n) &#x3D;&gt;
    changes.push(
      new InsertChange(
        sourcePath,
        getLineStartFromTSFile(source, n.getStart()),
        &#x60;${comment}&#x60;
      )
    )
  );
  return changes;
}

export function insertCommentAboveIdentifier(
  sourcePath: string,
  source: ts.SourceFile,
  identifierName: string,
  comment: string,
  identifierType &#x3D; ts.SyntaxKind.Identifier
): Change[] {
  const changes: InsertChange[] &#x3D; [];

  getSourceNodes(source).forEach((node) &#x3D;&gt; {
    if (node.kind !&#x3D;&#x3D; ts.SyntaxKind.ClassDeclaration) {
      return;
    }

    const identifierNodes &#x3D; findNodes(node, identifierType).filter(
      (identifierNode) &#x3D;&gt; identifierNode.getText() &#x3D;&#x3D;&#x3D; identifierName
    );

    identifierNodes.forEach((n) &#x3D;&gt;
      changes.push(
        new InsertChange(
          sourcePath,
          getLineStartFromTSFile(source, n.getStart()),
          &#x60;${comment}&#x60;
        )
      )
    );
  });

  return changes;
}

function getImportDeclarations(
  source: ts.SourceFile,
  importPath: string
): ts.ImportDeclaration[] {
  const imports &#x3D; getSourceNodes(source).filter(
    (node) &#x3D;&gt; node.kind &#x3D;&#x3D;&#x3D; ts.SyntaxKind.ImportDeclaration
  );
  return imports.filter((imp) &#x3D;&gt;
    ((imp as ts.ImportDeclaration).moduleSpecifier as ts.StringLiteral)
      .getText()
      .includes(importPath)
  ) as ts.ImportDeclaration[];
}

function filterNamespacedImports(
  imports: ts.ImportDeclaration[]
): ts.ImportDeclaration[] {
  return imports
    .filter((imp) &#x3D;&gt; (imp.importClause?.namedBindings as any)?.name)
    .filter(Boolean);
}

function filterNamedImports(
  imports: ts.ImportDeclaration[]
): ts.ImportDeclaration[] {
  return imports
    .filter((imp) &#x3D;&gt; (imp.importClause?.namedBindings as any)?.elements)
    .filter(Boolean);
}

export function insertCommentAboveImportIdentifier(
  sourcePath: string,
  source: ts.SourceFile,
  identifierName: string,
  importPath: string,
  comment: string
): Change[] {
  const imports &#x3D; getImportDeclarations(source, importPath);
  const namedImports &#x3D; filterNamedImports(imports);
  const namespacedImports &#x3D; filterNamespacedImports(imports);

  const namespacedIdentifiers &#x3D; namespacedImports
    .map((imp) &#x3D;&gt; (imp.importClause?.namedBindings as any)?.name?.escapedText)
    .filter(Boolean);
  const namedImportsWithIdentifierName &#x3D; namedImports.filter((imp) &#x3D;&gt;
    findNodes(imp, ts.SyntaxKind.ImportSpecifier).find(
      (node) &#x3D;&gt; (node as any).name.escapedText &#x3D;&#x3D;&#x3D; identifierName
    )
  );

  const propertyAccessExpressions &#x3D; getSourceNodes(source).filter(
    (node) &#x3D;&gt; node.kind &#x3D;&#x3D;&#x3D; ts.SyntaxKind.PropertyAccessExpression
  );

  const accessPropertiesToIdentifierName &#x3D; propertyAccessExpressions
    .filter((member) &#x3D;&gt;
      namespacedIdentifiers.includes((member as any)?.expression?.escapedText)
    )
    .filter((member) &#x3D;&gt; identifierName &#x3D;&#x3D;&#x3D; (member as any)?.name?.escapedText)
    .filter(Boolean);

  const changes: InsertChange[] &#x3D; [];

  namedImportsWithIdentifierName.forEach((n) &#x3D;&gt;
    changes.push(
      new InsertChange(
        sourcePath,
        getLineStartFromTSFile(source, n.getStart()),
        comment
      )
    )
  );

  accessPropertiesToIdentifierName.forEach((n) &#x3D;&gt;
    changes.push(
      new InsertChange(
        sourcePath,
        getLineStartFromTSFile(source, n.getStart()),
        comment
      )
    )
  );

  return changes;
}

export function renameIdentifierNode(
  sourcePath: string,
  source: ts.SourceFile,
  oldName: string,
  newName: string
): ReplaceChange[] {
  const identifierNodes &#x3D; findLevel1NodesInSourceByTextAndKind(
    source,
    oldName,
    ts.SyntaxKind.Identifier
  );
  const changes: ReplaceChange[] &#x3D; [];
  identifierNodes.forEach((n) &#x3D;&gt;
    changes.push(new ReplaceChange(sourcePath, n.getStart(), oldName, newName))
  );
  return changes;
}

function findLevel1NodesInSourceByTextAndKind(
  source: ts.SourceFile,
  text: string,
  syntaxKind: ts.SyntaxKind
): ts.Node[] {
  const nodes &#x3D; getSourceNodes(source);
  return findLevel1NodesByTextAndKind(nodes, text, syntaxKind);
}

function findLevel1NodesByTextAndKind(
  nodes: ts.Node[],
  text: string,
  syntaxKind: ts.SyntaxKind
): ts.Node[] {
  return nodes
    .filter((n) &#x3D;&gt; n.kind &#x3D;&#x3D;&#x3D; syntaxKind)
    .filter((n) &#x3D;&gt; n.getText() &#x3D;&#x3D;&#x3D; text);
}

export function findMultiLevelNodesByTextAndKind(
  nodes: ts.Node[],
  text: string,
  syntaxKind: ts.SyntaxKind
): ts.Node[] {
  const result: ts.Node[] &#x3D; [];
  for (const node of nodes) {
    result.push(
      ...findNodes(node, syntaxKind).filter((n) &#x3D;&gt; n.getText() &#x3D;&#x3D;&#x3D; text)
    );
  }
  return result;
}

function getLineStartFromTSFile(
  source: ts.SourceFile,
  position: number
): number {
  const lac &#x3D; source.getLineAndCharacterOfPosition(position);
  return source.getPositionOfLineAndCharacter(lac.line, 0);
}

// as this is copied from https://github.com/angular/angular-cli/blob/master/packages/schematics/angular/app-shell/index.ts#L211, no need to test Angular&#x27;s code
export function getMetadataProperty(
  metadata: ts.Node,
  propertyName: string
): ts.PropertyAssignment {
  const properties &#x3D; (metadata as ts.ObjectLiteralExpression).properties;
  const property &#x3D; properties.filter((prop) &#x3D;&gt; {
    if (!ts.isPropertyAssignment(prop)) {
      return false;
    }
    const name &#x3D; prop.name;
    switch (name.kind) {
      case ts.SyntaxKind.Identifier:
        return (name as ts.Identifier).getText() &#x3D;&#x3D;&#x3D; propertyName;
      case ts.SyntaxKind.StringLiteral:
        return (name as ts.StringLiteral).text &#x3D;&#x3D;&#x3D; propertyName;
    }

    return false;
  })[0];

  return property as ts.PropertyAssignment;
}

export function getLineFromTSFile(
  host: Tree,
  path: string,
  position: number
): [number, number] {
  const tsFile &#x3D; getTsSourceFile(host, path);

  const lac &#x3D; tsFile.getLineAndCharacterOfPosition(position);
  const lineStart &#x3D; tsFile.getPositionOfLineAndCharacter(lac.line, 0);
  const nextLineStart &#x3D; tsFile.getPositionOfLineAndCharacter(lac.line + 1, 0);

  return [lineStart, nextLineStart - lineStart];
}

export function getServerTsPath(host: Tree): string | undefined {
  const projectName &#x3D; getDefaultProjectNameFromWorkspace(host);
  const angularJson &#x3D; getAngularJsonFile(host);
  return angularJson.projects[projectName].architect?.server?.options?.main;
}
</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'DeprecatedNode.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       
       <script type="module" src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
