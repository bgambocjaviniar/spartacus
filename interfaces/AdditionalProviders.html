<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>storefrontapp documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css" media="(prefers-color-scheme: dark)">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">storefrontapp documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li
  >
  AdditionalProviders</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/schematics/src/shared/utils/feature-utils.ts</code>
        </p>


            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Custom schematics configuration providers.</p>

            </p>


        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#content" 
>
                                            content
                                        </a>
                                </li>
                                <li>
                                        <a href="#import" 
>
                                            import
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="content"></a>
                                        <span class="name "><b>content</b>
                                            <a href="#content">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>content:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="import"></a>
                                        <span class="name "><b>import</b>
                                            <a href="#import">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>import:         <code><a href="../interfaces/Import.html" target="_self" >Import[]</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../interfaces/Import.html" target="_self" >Import[]</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {
  chain,
  externalSchematic,
  noop,
  Rule,
  SchematicContext,
  SchematicsException,
  Tree,
} from &#x27;@angular-devkit/schematics&#x27;;
import {
  ArrowFunction,
  CallExpression,
  Expression,
  Identifier,
  Node,
  SourceFile,
  ts as tsMorph,
} from &#x27;ts-morph&#x27;;
import { Schema as SpartacusOptions } from &#x27;../../add-spartacus/schema&#x27;;
import { Schema as SpartacusWrapperOptions } from &#x27;../../wrapper-module/schema&#x27;;
import { ANGULAR_CORE } from &#x27;../constants&#x27;;
import {
  SPARTACUS_FEATURES_MODULE,
  SPARTACUS_FEATURES_NG_MODULE,
  SPARTACUS_SCHEMATICS,
} from &#x27;../libs-constants&#x27;;
import {
  featureFeatureModuleMapping,
  featureSchematicConfigMapping,
  getKeyByMappingValueOrThrow,
  getSchematicsConfigByFeatureOrThrow,
} from &#x27;../schematics-config-mappings&#x27;;
import { crossFeatureInstallationOrder } from &#x27;./graph-utils&#x27;;
import {
  findDynamicImport,
  getDynamicImportImportPath,
  isImportedFrom,
  isRelative,
  staticImportExists,
} from &#x27;./import-utils&#x27;;
import {
  addLibraryFeature,
  checkAppStructure,
  LibraryOptions,
  Module,
  SchematicConfig,
} from &#x27;./lib-utils&#x27;;
import { getModulePropertyInitializer, Import } from &#x27;./new-module-utils&#x27;;
import { createProgram } from &#x27;./program&#x27;;
import { getProjectTsConfigPaths } from &#x27;./project-tsconfig-paths&#x27;;

export interface FeatureModuleImports {
  importPath: string;
  moduleNode: Expression | Identifier;
}

/**
 * Custom schematics configuration providers.
 */
export interface AdditionalProviders {
  import: Import[];
  content: string;
}

/**
 * Additional schematics configurations / overrides.
 */
export interface AdditionalFeatureConfiguration&lt;T &#x3D; LibraryOptions&gt; {
  /**
   * If specified, provides the specified configuration.
   */
  providers?: AdditionalProviders | AdditionalProviders[];
  /**
   * If specified, overrides the pre-defined schematics options.
   */
  options?: T;
}

/**
 * Analysis result of wrapper module configuration.
 */
interface WrapperAnalysisResult {
  /**
   * Marker name.
   */
  markerModuleName: string;
  /**
   * Options.
   */
  wrapperOptions: SpartacusWrapperOptions;
}

/**
 * Configures feature modules for the given array of features.
 *
 * Optionally, an override can be provided for the default
 * schematics options and/or feature-schematics configuration.
 */
export function addFeatures&lt;OPTIONS extends LibraryOptions&gt;(
  options: OPTIONS,
  features: string[]
): Rule {
  return (_tree: Tree, context: SchematicContext): Rule &#x3D;&gt; {
    if (options.debug) {
      let message &#x3D; &#x60;\n******************************\n&#x60;;
      message +&#x3D; &#x60;Cross feature graph:\n&#x60;;
      message +&#x3D; crossFeatureInstallationOrder.join(&#x27;, &#x27;);
      message +&#x3D; &#x60;\n******************************\n&#x60;;
      context.logger.info(message);
    }

    /**
     * In an existing Spartacus application, we don&#x27;t want to
     * force-install the dependent features.
     */
    const featuresToInstall &#x3D; options.internal?.existingSpartacusApplication
      ? options.features ?? []
      : features;

    const rules: Rule[] &#x3D; [];
    for (const feature of featuresToInstall) {
      const schematicsConfiguration &#x3D;
        featureSchematicConfigMapping.get(feature);
      if (!schematicsConfiguration) {
        throw new SchematicsException(
          &#x60;[Internal] No feature config found for ${feature}. &#x60; +
            &#x60;Please check if  the schematics config is added to projects/schematics/src/shared/schematics-config-mappings.ts&#x60;
        );
      }

      // TODO:#schematics - fix the interactivity for the CDS / ASM, etc.
      const libraryOptions &#x3D;
        schematicsConfiguration.customConfig?.(options).options ?? options;

      rules.push(addLibraryFeature(libraryOptions, schematicsConfiguration));

      const wrappers &#x3D; analyzeWrappers(schematicsConfiguration, libraryOptions);
      for (const { wrapperOptions } of wrappers) {
        rules.push(
          externalSchematic(
            SPARTACUS_SCHEMATICS,
            &#x27;wrapper-module&#x27;,
            wrapperOptions
          )
        );
      }
    }

    return chain(rules);
  };
}

/**
 * Analyzes the given schematics configuration for the wrapper modules.
 * It builds the options for the wrapper schematic run,
 * including the execution sequence.
 */
function analyzeWrappers&lt;OPTIONS extends LibraryOptions&gt;(
  schematicsConfiguration: SchematicConfig,
  options: OPTIONS
): WrapperAnalysisResult[] {
  if (!schematicsConfiguration.importAfter?.length) {
    return [];
  }

  const result: WrapperAnalysisResult[] &#x3D; [];
  for (const importAfterConfig of schematicsConfiguration.importAfter) {
    const wrapperOptions: SpartacusWrapperOptions &#x3D; {
      scope: options.scope,
      interactive: options.interactive,
      project: options.project,
      markerModuleName: importAfterConfig.markerModuleName,
      featureModuleName: importAfterConfig.featureModuleName,
      debug: options.debug,
    };

    const analysis: WrapperAnalysisResult &#x3D; {
      markerModuleName: importAfterConfig.markerModuleName,
      wrapperOptions,
    };
    result.push(analysis);
  }

  return result;
}

/**
 * If exists, it returns the spartacus-features.module.ts&#x27; source.
 * Otherwise, it returns undefined.
 */
export function getSpartacusFeaturesModule(
  tree: Tree,
  basePath: string,
  tsconfigPath: string
): SourceFile | undefined {
  const { appSourceFiles } &#x3D; createProgram(tree, basePath, tsconfigPath);

  for (const sourceFile of appSourceFiles) {
    if (
      sourceFile
        .getFilePath()
        .includes(&#x60;${SPARTACUS_FEATURES_MODULE}.module.ts&#x60;)
    ) {
      if (getSpartacusFeaturesNgModuleDecorator(sourceFile)) {
        return sourceFile;
      }
    }
  }
  return undefined;
}

/**
 * Returns the NgModule decorator, if exists.
 */
function getSpartacusFeaturesNgModuleDecorator(
  sourceFile: SourceFile
): CallExpression | undefined {
  let spartacusFeaturesModule: CallExpression | undefined;

  function visitor(node: Node) {
    if (Node.isCallExpression(node)) {
      const expression &#x3D; node.getExpression();
      if (
        Node.isIdentifier(expression) &amp;&amp;
        expression.getText() &#x3D;&#x3D;&#x3D; &#x27;NgModule&#x27; &amp;&amp;
        isImportedFrom(expression, ANGULAR_CORE)
      ) {
        const classDeclaration &#x3D; node.getFirstAncestorByKind(
          tsMorph.SyntaxKind.ClassDeclaration
        );
        if (classDeclaration) {
          const identifier &#x3D; classDeclaration.getNameNode();
          if (
            identifier &amp;&amp;
            identifier.getText() &#x3D;&#x3D;&#x3D; SPARTACUS_FEATURES_NG_MODULE
          ) {
            spartacusFeaturesModule &#x3D; node;
          }
        }
      }
    }

    node.forEachChild(visitor);
  }

  sourceFile.forEachChild(visitor);
  return spartacusFeaturesModule;
}

/**
 * For the given feature module name,
 * returns the module configuration part
 * of the given schematics feature config
 */
export function getModuleConfig(
  featureModuleName: string,
  featureConfig: SchematicConfig
): Module | undefined {
  const featureModuleConfigs &#x3D; ([] as Module[]).concat(
    featureConfig.featureModule
  );
  for (const featureModuleConfig of featureModuleConfigs) {
    if (featureModuleConfig.name &#x3D;&#x3D;&#x3D; featureModuleName) {
      return featureModuleConfig;
    }
  }

  return undefined;
}

/**
 * Analyzes the customers&#x27; application.
 * It checks for presence of Spartacus features and
 * whether they&#x27;re configured or present in package.json.
 */
export function analyzeApplication&lt;OPTIONS extends LibraryOptions&gt;(
  options: OPTIONS,
  allFeatures: string[]
): Rule {
  return (tree: Tree, context: SchematicContext) &#x3D;&gt; {
    const spartacusFeatureModuleExists &#x3D; checkAppStructure(
      tree,
      options.project
    );
    /**
     * Mutates the options, and sets the internal properties
     * for later usage in other rules.
     */
    options.internal &#x3D; {
      ...options.internal,
      existingSpartacusApplication: spartacusFeatureModuleExists,
    };

    if (!options.internal.existingSpartacusApplication) {
      const dependentFeaturesMessage &#x3D; createDependentFeaturesLog(
        options,
        allFeatures
      );
      if (dependentFeaturesMessage) {
        context.logger.info(dependentFeaturesMessage);
      }

      return noop();
    }

    if (options.debug) {
      context.logger.info(&#x60;⌛️ Analyzing application...&#x60;);
    }

    for (const targetFeature of options.features ?? []) {
      const targetFeatureConfig &#x3D;
        getSchematicsConfigByFeatureOrThrow(targetFeature);
      if (!targetFeatureConfig.importAfter?.length) {
        continue;
      }

      const wrappers &#x3D; analyzeWrappers(targetFeatureConfig, options);
      for (const { wrapperOptions } of wrappers) {
        const markerFeature &#x3D; getKeyByMappingValueOrThrow(
          featureFeatureModuleMapping,
          wrapperOptions.markerModuleName
        );

        const markerFeatureConfig &#x3D;
          getSchematicsConfigByFeatureOrThrow(markerFeature);
        const markerModuleConfig &#x3D; getModuleConfig(
          wrapperOptions.markerModuleName,
          markerFeatureConfig
        );
        if (!markerModuleConfig) {
          continue;
        }

        if (markerModuleExists(options, tree, markerModuleConfig)) {
          continue;
        }

        const targetModuleName &#x3D; wrapperOptions.featureModuleName;
        const targetFeature &#x3D; getKeyByMappingValueOrThrow(
          featureFeatureModuleMapping,
          targetModuleName
        );
        const targetFeatureConfig &#x3D;
          getSchematicsConfigByFeatureOrThrow(targetFeature);
        const targetModuleConfig &#x3D; getModuleConfig(
          targetModuleName,
          targetFeatureConfig
        );

        let message &#x3D; &#x60;Attempted to append &#x27;${targetModuleName}&#x27; module &#x60;;
        message +&#x3D; &#x60;from &#x27;${targetModuleConfig?.importPath}&#x27; after the &#x60;;
        message +&#x3D; &#x60;&#x27;${wrapperOptions.markerModuleName}&#x27; from &#x27;${markerModuleConfig.importPath}&#x27;, &#x60;;
        message +&#x3D; &#x60;but could not find &#x27;${wrapperOptions.markerModuleName}&#x27;.&#x60;;
        message +&#x3D; &#x60;\n&#x60;;
        message +&#x3D; &#x60;Please make sure the &#x27;${markerFeature}&#x27; is installed by running:\n&#x60;;
        message +&#x3D; &#x60;&gt; ng add @spartacus/schematics --features&#x3D;${markerFeature}&#x60;;

        throw new SchematicsException(message);
      }
    }

    if (options.debug) {
      context.logger.info(&#x60;✅  Application analysis complete.&#x60;);
    }
  };
}

function markerModuleExists&lt;OPTIONS extends LibraryOptions&gt;(
  options: OPTIONS,
  tree: Tree,
  markerModuleConfig: Module
): boolean {
  const basePath &#x3D; process.cwd();
  const { buildPaths } &#x3D; getProjectTsConfigPaths(tree, options.project);
  for (const tsconfigPath of buildPaths) {
    const { appSourceFiles } &#x3D; createProgram(tree, basePath, tsconfigPath);
    if (findFeatureModule(markerModuleConfig, appSourceFiles)) {
      return true;
    }
  }

  return false;
}

/**
 * Searches through feature modules,
 * and looks for either the static or
 * dynamic imports.
 */
export function findFeatureModule(
  moduleConfig: Module | Module[],
  appSourceFiles: SourceFile[]
): SourceFile | undefined {
  const moduleConfigs &#x3D; ([] as Module[]).concat(moduleConfig);
  for (const sourceFile of appSourceFiles) {
    for (const moduleConfig of moduleConfigs) {
      if (isStaticallyImported(sourceFile, moduleConfig)) {
        return sourceFile;
      }

      if (isDynamicallyImported(sourceFile, moduleConfig)) {
        return sourceFile;
      }
    }
  }

  return undefined;
}

function isStaticallyImported(
  sourceFile: SourceFile,
  moduleConfig: Module
): boolean {
  if (
    !staticImportExists(sourceFile, moduleConfig.importPath, moduleConfig.name)
  ) {
    false;
  }

  const elements &#x3D;
    getModulePropertyInitializer(sourceFile, &#x27;imports&#x27;, false)?.getElements() ??
    [];
  for (const element of elements) {
    const moduleName &#x3D; element.getText().split(&#x27;.&#x27;).pop() ?? &#x27;&#x27;;

    if (moduleName &#x3D;&#x3D;&#x3D; moduleConfig.name) {
      return true;
    }
  }

  return false;
}

function isDynamicallyImported(
  sourceFile: SourceFile,
  moduleConfig: Module
): boolean {
  return !!findDynamicImport(sourceFile, {
    moduleSpecifier: moduleConfig.importPath,
    namedImports: [moduleConfig.name],
  });
}

/**
 * Peeks into the given dynamic import,
 * and returns referenced local source file.
 */
export function getDynamicallyImportedLocalSourceFile(
  dynamicImport: ArrowFunction
): SourceFile | undefined {
  const importPath &#x3D; getDynamicImportImportPath(dynamicImport) ?? &#x27;&#x27;;
  if (!isRelative(importPath)) {
    return;
  }

  const wrapperModuleFileName &#x3D; &#x60;${importPath.split(&#x27;/&#x27;).pop()}.ts&#x60;;
  return dynamicImport
    .getSourceFile()
    .getProject()
    .getSourceFile((s) &#x3D;&gt; s.getFilePath().endsWith(wrapperModuleFileName));
}

function createDependentFeaturesLog(
  options: SpartacusOptions,
  features: string[]
): string | undefined {
  const selectedFeatures &#x3D; options.features ?? [];
  const notSelectedFeatures &#x3D; features.filter(
    (feature) &#x3D;&gt; !selectedFeatures.includes(feature)
  );

  if (!notSelectedFeatures.length) {
    return;
  }

  return &#x60;\n⚙️ Configuring the dependent features of ${selectedFeatures.join(
    &#x27;, &#x27;
  )}: ${notSelectedFeatures.join(&#x27;, &#x27;)}\n&#x60;;
}
</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'AdditionalProviders.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       
       <script type="module" src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
